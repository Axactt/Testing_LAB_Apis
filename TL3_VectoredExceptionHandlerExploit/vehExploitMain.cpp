#define STATUS_INSUFFICIENT_MEM       0xE0000001
#define STATUS_FILE_BAD_FORMAT        0xE0000002
// Strat it without debugger otherwise exception will be catched by debugger
#include<stdio.h>
#include<Windows.h>

//! This registers a custom Filter-Handler to be invoked upon and checked 
long __stdcall PVectoredExceptionCallBack( EXCEPTION_POINTERS* expt_ptr_info );

int main()
{
	puts( "[!]First entry at top of  main()" );
	puts( "[!] Press Enter to continue execution and hit articficial breakpoint." );
	getchar();
	__debugbreak();

	static bool first_execution = true;
	if (first_execution)
	{
		first_execution = false;
		/*registers an exception handler to catch the exception raised by raiseException function
		* returns the handle PVOID to the VectoredExceptionCallBack handler
		* PVectoreddExceptionCallback takes in pointer to an EXCEPTION_POINTERS
		* structure that recieves the exception record and contextRecord information
		* all the information and further manipulation of thread can be done
		* using this EXCEPTION_POINTERS structurte which is in parameter of callback
		*/
		puts( "[!] Press Enter to continue execution and addVecoredExceptionHandler." );
		getchar();
		AddVectoredExceptionHandler( 1, PVectoredExceptionCallBack );
		/*RaiseException function raises an exception in the calling thread with
		* an application defined exception code of the exception being raised.
		* it enables the process to use astructured excption handling to handle
		* private,software-generated,aplication defined exceptions
		* Can be viewed like throw statement of C++ returning an exception of a type
		* RaiseException raises exception in calling thread with application defined
		* exception-code of the exception being raised; and the application defined
		* exception flag that can be either 0 to indicate a continuable exception or
		* non-contnuable exception along with flag numbers and flagArray pointer
		* So basically like a throw statement of c++ exception handling
		*/

		puts( "[!] Press Enter to continue execution and RaiseException by RaiseException() api." );
		getchar();
		RaiseException( STATUS_FILE_BAD_FORMAT, 0, 0, 0 );
	}

	puts( "[!]Second entry to main" );
	return 0;
}
/*typedef struct _EXCEPTION_POINTERS {
  PEXCEPTION_RECORD ExceptionRecord; //pointer to xception record
  PCONTEXT          ContextRecord; //pointer to context record
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
Contains an exception record with a machine-independent description
of an exception and a context record with a machine-dependent description of the processor context at the time of the exception.
*/
/* As the exception has been raised by RaiseException and a vecotredException
* Registered by AddVectoredExceptionHandler() function with priority 1(FIRST)
* PVectoredExceptionCallBack handler will be checked first after RaiseExcption
 */

//! A VEH handler may be able to correct some state and allow the code to recover from the exception.For that, it should return EXCEPTION_CONTINUE_EXECUTION
//!  If all VEH handlers returned EXCEPTION_CONTINUE_SEARCH, SEH handlers are now invoked
//! Returning EXCEPTION_EXECUTE_- HANDLER is not allowed by VEH handlers.
//! 
long __stdcall PVectoredExceptionCallBack( EXCEPTION_POINTERS* excpt_ptr_info )
{
	puts( "[!]Inside PVectored_Exception_handler callback invoked by RaisedException() api." );

	if (excpt_ptr_info->ExceptionRecord->ExceptionCode == STATUS_FILE_BAD_FORMAT)

	{	
		
		puts( "[!] Press Enter to continue execution and change RIP by context-record structure to top of main() ." );
		getchar();
		//!view other values in ContextRecord and edit them.
		excpt_ptr_info->ContextRecord->Rip = (uintptr_t) &main;

		/*AddVectoredExceptionHandler allows you to register your own filter. RaiseException simply causes that exception to happen.

		We filter out our raised exception (STATUS_INTEGER_DIVIDE_BY_ZERO) Then edit the RIP to point to main( );

		This is the main exploitation area:
		You can change the Rip to any other function, diverting the code there. You can mess with all registers and flags too.

		Other ways to force an exception:

		Hardware breakpoints
		Memory Protection (PAGE_GUARD for example)
		Push back page to disk
		INT 3 breakpoint
		INT 1 step
		fault error (divide by zero, stack overflow etc.)
		Hard coded exception on the IDT.

		Control is always parsed to kernel mode before the exception handlers, so handling from there is always better than from a registered VEH.
		Also remember that Your VEH will only by at the top of the handler list if it was the last one added, debuggers may register to this list also. (some games have their own debugger).*/

		//return by EXCEPTION_CONTINUE_EXECUTION to return at the point of exception 
				//xreturn -1;
		return EXCEPTION_CONTINUE_EXECUTION;
	}

	return 0;
}
